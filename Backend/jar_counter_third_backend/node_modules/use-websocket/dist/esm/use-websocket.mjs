import React from 'react';
import { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect.mjs';

// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState

// `readyState` alternative? Not sure about diverging from the WebSocket API
// Currently, a string literal representation of ReadyState. However, this
// could be extended to include additional custom states(e.g. 'error')
const initialState = {
  webSocket: null,
  readyState: 0,
  status: 'connecting'
};
function reducer(_state, action) {
  switch (action.type) {
    case 'connecting':
      return {
        webSocket: null,
        readyState: 0,
        status: 'connecting'
      };
    case 'open':
      return {
        webSocket: action.webSocket,
        readyState: 1,
        status: 'open'
      };
    case 'closing':
      return {
        webSocket: null,
        readyState: 2,
        status: 'closing'
      };
    case 'closed':
      return {
        webSocket: null,
        readyState: 3,
        status: 'closed'
      };
    default:
      // TODO: Should this instead be a custom error state?
      throw new Error(`Unknown action.type`);
  }
}
function useWebSocket(url, options) {
  const [state, dispatch] = React.useReducer(reducer, initialState);
  const handleOpen = React.useRef();
  const handleClose = React.useRef();
  const handleError = React.useRef();
  const handleMessage = React.useRef();
  // const protocols = React.useRef<UseWebSocketOptions['protocols']>()

  // Remember the latest callback if it changes.
  useIsomorphicLayoutEffect(() => {
    handleOpen.current = options.onOpen;
  }, [options.onOpen]);
  useIsomorphicLayoutEffect(() => {
    handleClose.current = options.onClose;
  }, [options.onClose]);
  useIsomorphicLayoutEffect(() => {
    handleError.current = options.onError;
  }, [options.onError]);
  useIsomorphicLayoutEffect(() => {
    handleMessage.current = options.onMessage;
  }, [options.onMessage]);

  // useIsomorphicLayoutEffect(() => {
  //   protocols.current = options.protocols
  // }, [options.protocols])

  React.useEffect(() => {
    dispatch({
      type: 'connecting'
    });
    const webSocket = new WebSocket(url);
    if (handleMessage.current) {
      webSocket.addEventListener('message', handleMessage.current);
    }
    webSocket.addEventListener('open', event => {
      var _handleOpen$current;
      dispatch({
        type: 'open',
        webSocket
      });
      (_handleOpen$current = handleOpen.current) === null || _handleOpen$current === void 0 ? void 0 : _handleOpen$current.call(handleOpen, event);
    });
    webSocket.addEventListener('close', event => {
      var _handleClose$current;
      dispatch({
        type: 'closed'
      });
      (_handleClose$current = handleClose.current) === null || _handleClose$current === void 0 ? void 0 : _handleClose$current.call(handleClose, event);
    });
    webSocket.addEventListener('error', event => {
      var _handleError$current;
      // Spec'd to call the error event before the close event
      dispatch({
        type: 'closing'
      });
      (_handleError$current = handleError.current) === null || _handleError$current === void 0 ? void 0 : _handleError$current.call(handleError, event);
    });
    return () => {
      webSocket.close();
    };
  }, [url]);
  return {
    webSocket: state.webSocket,
    readyState: state.readyState,
    status: state.status
  };
}

export { useWebSocket };
